<h2>Подключение объектов из другого модуля в C++/CLI</h2>
<p>Date: 23.02.2017 7:01:34</p>
<div>
<p>То, что вы хотите сделать, не работает.</p>
<p>Директива using позволяет лишь добавить в область види&#1084;ости объекты из внешнего пространства и&#1084;ен. Она не от&#1084;еняет необходи&#1084;ости объявления объекта, определенного в друго&#1084; &#1084;одуле (что и содержится в заголовочно&#1084;
 файле). </p>
</div>
<h2>Message 924</h2>
<p>Date: 26.02.2017 13:53:34</p>
<div>
<p></p>
Сборка System::Windows::Forms подключена к проекту как внешняя (на нее добавлена ссылка в свойствах проекта), поэто&#1084;у ее определение берется из &#1084;етаданных сборки и заголовочный файл не нужен. У управляе&#1084;ых сборок вообще нет ни заголовочных
 файлов ни библиотек и&#1084;порта, поскольку все необходи&#1084;ые данные об экспортируе&#1084;ых объектах содержатся в са&#1084;ой сборке.&nbsp;<br/>
<br/>
Ва&#1084; следует понять следующее: директива using не влияет ни на что, кро&#1084;е види&#1084;ости объектов. Все что она делает, это позволяет писать Form2 в&#1084;есто MyProject::Form2, она не подключает никаких внешних объектов. В языке с&#43;&#43;, использованию
 класса должно предшествовать его объявление, это правило. Если вы используете стандартную структуру проекта WinForms CLI: один &#1084;одуль MyProject.cpp &#43; сгенерированные конструкторо&#1084; Form1.h ... FormN.h, правильны&#1084; способо&#1084; обеспечить
 выполнение этого правила является включение в MyProject.cpp директив include в правильной последовательности. Напри&#1084;ер, если Form1 использует Form2, MyProject.cpp должен выглядеть так.<br/>
<br/>
<pre class="prettyprint">// MyProject.cpp: главный файл проекта.

#include &quot;Form2.h&quot;
#include &quot;Form1.h&quot;

using namespace MyProject;

[STAThreadAttribute]
int main(array&lt;System::String ^&gt; ^args)
{
	// Включение визуальных эффектов Windows XP до создания каких-либо эле&#1084;ентов управления
	Application::EnableVisualStyles();
	Application::SetCompatibleTextRenderingDefault(false); 

	// Создание главного окна и его запуск
	Application::Run(gcnew Form1());
	return 0;
}</pre>
<br/>
Тогда в Form1.h &#1084;ы &#1084;оже&#1084; использовать Form2 без каких-либо дополнительных директив:<br/>
<br/>
<pre class="prettyprint">private: System::Void button1_Click(System::Object^  sender, System::EventArgs^  e) 
{
	MyProject::Form2 ^ frm=gcnew MyProject::Form2();
	frm-&gt;Show(this);
}</pre>
<br/>
Если же у вас несколько &#1084;одулей, то классы должны разбиваться на объявление (в заголовках) и реализацию (в cpp-файлах), и опять, заголовки должны подключаться к &#1084;одуля&#1084; в правильной последовательности. Путаница тут возникает из-за того, что
 встречаются две разные иделогии подключения внешних объектов: управляе&#1084;ого кода (с авто&#1084;атически загружае&#1084;ы&#1084;и &#1084;етаданны&#1084;и) и неуправляе&#1084;ого кода (с требование&#1084; явного объявления объекта до его использования).
 Это приводит к забавно&#1084;у факту, что объект из внешней сборки подключить &quot;проще&quot; че&#1084; объект из своего проекта.
<p></p>
<br/>
</div>

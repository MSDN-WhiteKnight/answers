<h2>Message 351</h2>
<p>Date: 06.11.2018 9:18:39</p>
<div>
<p>Как вариант, исчерпание ThreadPool. Попробуйте в&#1084;есте с протоколирование&#1084; запуска &#1084;етода также протоколировать количество доступных потоков в ThreadPool (<a href="https://docs.microsoft.com/ru-ru/dotnet/api/system.threading.threadpool.getavailablethreads?view=netframework-4.7.2">https://docs.microsoft.com/ru-ru/dotnet/api/system.threading.threadpool.getavailablethreads?view=netframework-4.7.2</a>)</p>
<p></p>
</div>
<h2>Message 350</h2>
<p>Date: 07.11.2018 8:00:58</p>
<div>
Не знаю. Исчерпание ThreadPool часто вызывает зависания или взаи&#1084;облокировки под нагрузкой при неправильно&#1084; использовании TPL и асинхронности.&nbsp; А че&#1084; отличается пробле&#1084;ная конечная точка от других?
</div>
<h2>Message 349</h2>
<p>Date: 07.11.2018 11:51:53</p>
<div>
&nbsp;У вас по данны&#1084; счетчиков производительности значение Faulted Calls постоянно растет. Такое поведение с са&#1084;ого начала работы сервиса идет, или только после начала зависаний? Вы исключения в WCF-&#1084;етодах как-то обрабатываете, преобразуете
 в Fault-сообщения, или просто позволяете &#1084;етоду упасть?<br/>
</div>
<h2>Message 348</h2>
<p>Date: 08.11.2018 4:47:21</p>
<div>
Ну тогда печаль, по те&#1084; данны&#1084;, которые вы предоставили, не вижу что &#1084;ожет вызвать такую пробле&#1084;у. По счетчика&#1084; производительности, нагрузка хоть и значительна, но не настолько, чтобы упираться в ограничения, соответствующие
 конфигурации, даже если каждый клиент забывал бы закрыть соединение. Либо вы в коде что-то такое делаете, что не выдерживает нагрузки, либо пробле&#1084;а на стороне ОС/драйверов/железа.
</div>

<h2>Message 904</h2>
<p>Date: 08.03.2017 17:59:12</p>
<div>
<p>Мда, преобразование результатов c_str в LPSTR с по&#1084;ощью const_cast это конечно изврат высшей степени.</p>
<p>Как бы то ни было, програ&#1084;&#1084;а крашится похоже из-за банального выхода за границу &#1084;ассива. В&#1084;есто
</p>
<pre class="prettyprint">for(int i=0;i&lt;=*num;i&#43;&#43;)</pre>
<p><br/>
</p>
<p>напишите&nbsp;</p>
<pre class="prettyprint">for(int i=0;i&lt;*num;i&#43;&#43;)</pre>
<br/>
<p><br/>
</p>
<p></p>
</div>
<h2>Message 903</h2>
<p>Date: 08.03.2017 19:30:38</p>
<div>
<p>Результат функции c_str нельзя &#1084;одифицировать&nbsp;(поэто&#1084;у, собственно, он и константный)&nbsp;, кро&#1084;е того он действителен только пока существует исходный объект std::string. Данный способ будет работать, пока вы не &#1084;одифицируете
 &#1084;ассив си&#1084;волов и не уничтожаете исходную строку. Если вы забудете про это, будет исключение или непредсказуе&#1084;ый результат.</p>
<p>Правильно делать так: выделить па&#1084;ять под &#1084;ассив си&#1084;волов (раз&#1084;ер = длина строки &#43; 1) операторо&#1084; new и скопировать туда си&#1084;волы функцией strncpy (заголовочный файл string.h).</p>
<strong>Добавлено</strong>: кстати, функция WritePrivateProfileString вообще-то прини&#1084;ает LPCSTR, так что вы &#1084;огли ничего не преобразовывать.
</div>

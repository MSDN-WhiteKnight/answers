<h2>Message 98</h2>
<p>Date: 29.11.2020 13:16:21</p>
<div>
<p>BinaryReader.ReadString, конечно, считывает строку полностью, кро&#1084;е случая, когда отправляющая сторона разорвет соединение до передачи всей строки. Никакого понятия &quot;не успеет&quot; здесь нет.
</p>
<p>Реальная пробле&#1084;а вашего кода в этих строках:</p>
<pre class="prettyprint">Catch ex As Exception
            ConnectStatus = False
End Try</pre>
Вы игнорируете все исключения и те&#1084; са&#1084;ы&#1084; делаете невоз&#1084;ожны&#1084; диагностику ошибок<br/>
<p></p>
<p></p>
&nbsp;
</div>
<h2>Message 97</h2>
<p>Date: 30.11.2020 3:34:47</p>
<div>
Эту ошибку &#1084;ожно как раз проигнорировать, если все данные по факту пришли. Она возникает при вызове NetworkStream.Close на отправляющей стороне. Если же данные не приходят, надо отлаживать ваш код и выяснять поче&#1084;у, са&#1084;о по себе ничего
 потеряться не &#1084;ожет. Хотя, если проявляется только на определенных ко&#1084;пьютерах, не исключена и аппаратная или сетевая пробле&#1084;а.<br/>
</div>
<h2>Message 96</h2>
<p>Date: 30.11.2020 15:40:33</p>
<div>
<p>Соединение закрывается либо ручны&#1084; вызово&#1084; Close/Dispose, либо авто&#1084;атически при закрытии приложения или когда неиспользуе&#1084;ый NetworkStream подберет GC. Лучше конечно явно закрыть поток, когда он больше не нужен, но это не обязательно,
 данные должны отправляться и так. Метод Flush также вызывать не обязательно.&nbsp;&nbsp;</p>
<p></p>
</div>
<h2>Message 95</h2>
<p>Date: 02.12.2020 4:51:59</p>
<div>
Если сервер отвечает на запросы от нескольких клиентов, то да, обычно он должен быть &#1084;ногопоточны&#1084;. При подключении клиента уходи&#1084; в фоновый поток/Task, чтобы другие не ждали. А если обработка &#1084;ожет вообще зависнуть, тогда те&#1084;
 более. При это&#1084;, скорее всего, нужно добавить синхронизацию потоков, напри&#1084;ер, если разные потоки будут писать в один файл, чтобы данные не с&#1084;ешались.
</div>

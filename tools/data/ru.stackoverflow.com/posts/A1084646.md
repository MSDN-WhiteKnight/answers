---
title: "Ответ на \"Что происходит &quot;внутри&quot; при обращении к статическому методу не статического класса?\""
se.owner.user_id: 240512
se.owner.display_name: "MSDN.WhiteKnight"
se.owner.link: "https://ru.stackoverflow.com/users/240512/msdn-whiteknight"
se.answer_id: 1084646
se.question_id: 1084580
se.post_type: answer
se.is_accepted: True
---
<blockquote>
  <p>Что происходит под капотом при первом и последующих вызовах статического метода этого класса? Язык - c#</p>
</blockquote>

<p>Ничего особенного, в сущности. Тут скорее надо ставить вопрос по другому, что <strong>не</strong> происходит, по сравнению с вызовом метода экземпляра. Если взять код <code>Test.TestStatic("Hello, world");</code>, то на уровне IL он будет представлен так:</p>

<pre><code>ldstr      "Hello, world"
call       void Test::TestStatic(string)
</code></pre>

<p>То есть аргументы загружаются в стек, и управление передается вызываемому методу. Экземпляр класса нигде не фигурирует. Первый вызов будет отличаться только в случае, если это вообще первое обращение к классу за все время выполнения программы - тогда перед ним будет вызван статический конструктор и проинициализированы статические поля. Остальные вызовы идентичны.</p>

<p>Для сравнения, вызов метода экземпляра:</p>

<pre><code>ldloc.0
ldstr      "Hello, world"
callvirt   instance void Test::TestInstance(string)
</code></pre>

<p>Первая инструкция здесь загружает в стек ссылку на экземпляр класса (который хранится в локальной переменной 0) - она играет роль неявного первого параметра. Инструкция <code>callvirt</code> генерируется компилятором C# вместо <code>call</code> в том контексте, где ссылка на экземпляр может потенциально быть null, даже если метод не виртуальный, чтобы обеспечить корректную проверку на null и генерацию NullReferenceException. Но для вызова метода экземпляра может использоваться и <code>call</code>.</p>

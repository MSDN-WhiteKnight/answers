---
title: "Ответ на \"Что такое адрес функции?\""
se.owner.user_id: 240512
se.owner.display_name: "MSDN.WhiteKnight"
se.owner.link: "https://ru.stackoverflow.com/users/240512/msdn-whiteknight"
se.answer_id: 1108241
se.question_id: 1107372
se.post_type: answer
se.is_accepted: True
---
<p>Почему ваш код выводит одинаковые значения, на самом деле легко объяснить. Стандарт определяет стандартное неявное преобразование из типа функции в тип указатель на функцию: </p>

<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf" rel="nofollow noreferrer">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf</a></p>

<blockquote>
  <p>7.3 Function-to-pointer conversion [conv.func]
  1 An lvalue of function type T can be converted to a prvalue of type “pointer to T”. The result is a pointer to the function.</p>
</blockquote>

<p>Так как вывести в cout саму функцию нельзя, срабатывает это преобразование, и вы выводите в поток тот же указатель на функцию (точнее, результат его приведения к целочисленному типу). </p>

<p>А вот сказать определенно, что такое "адрес функции", уже сложнее. Стандарт определяет, что значением адреса объекта является адрес первого байта его данных, но для адреса функции нет аналогичного утверждения. Соответственно, приходится делать вывод, что адрес функции - это просто некоторое определяемое реализацией значение, которое не обязано совпадать с реальным адресом машинного кода функции в памяти. На практике так и есть, например, в Visual C++ в отладочной конфигурации <a href="https://ru.stackoverflow.com/questions/1005297/">значение указателя на функцию не совпадает с реальным адресом</a> (который можно получить через специальный API платформы).</p>

<p>Как их использовать? Судя по выводам предыдущего абзаца, никак... Вы можете брать указатель на функцию, хранить его и разыменовать для вызова функции, но само значение указателя для вас - "черный ящик".</p>

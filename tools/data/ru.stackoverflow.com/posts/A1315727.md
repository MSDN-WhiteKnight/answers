---
title: "Ответ на \"Достаточно быстрый ввод-вывод\""
se.owner.user_id: 240512
se.owner.display_name: "MSDN.WhiteKnight"
se.owner.link: "https://ru.stackoverflow.com/users/240512/msdn-whiteknight"
se.answer_id: 1315727
se.question_id: 1315485
se.post_type: answer
se.is_accepted: False
---
<p>Способы ввода-вывода не делятся на &quot;быстрые&quot; и &quot;медленные&quot;, потому что если бы это было так, все бы просто пользовались быстрыми, а смысла в медленных не было. Это касается не только соревнований, в реальных приложениях CLI также не отказались бы от способа считывать данные быстрее. Я думаю, авторы задачи в данном случае просто рекомендуют оптимизировать код под случай большого объема входных данных данных. Что это значит на практике? Тот код, который вы привели, можно было бы, теоретически, переписать вот таким образом:</p>

<pre><code>static void Main()
{
    string str = Console.In.ReadToEnd();
    string[] lines = str.Split(new char[]{'\r', '\n'},StringSplitOptions.RemoveEmptyEntries);
    string firstLine = lines[0];
    int testsCount = int.Parse(firstLine);

    for (int i = 1; i &lt;= testsCount; i++)
    {
        int[] line = lines[i].Split(' ').Select(int.Parse).ToArray();
        //...
    }                        
}
</code></pre>
<p>(Эта реализация не сработает на живой консоли, так как конца ввода как такового не будет, но, я полагаю, что тысячи строк не будут вводить вручную. При перенаправлении ввода из файла все работает, так как концом ввода будет конец файла.)</p>
<p>В плане &quot;алгоритмической&quot; сложности этот способ в принципе аналогичен вашему. Однако, его отличает то, что в память считываются все входные данные целиком. Если объем данных станет сопоставимым с размером доступной оперативной памяти, начнется интенсивное вытеснение страниц памяти на жесткий диск и обратно, благодаря чему этот способ будет работать сильно медленнее, чем способ с построчным считыванием. На маленьких объемах данных эту проблему не обнаружить, вероятно, поэтому авторы задачи и предупреждают об этом отдельно. В целом же, выжать что-то, пытаясь оптимизировать ввод/вывод вряд ли получится. У вас можно разве что выкинуть LINQ и этим чуть ускорить за счет меньших расходов на вызовы по интерфейсам. Думаю, этот способ вполне можно назвать &quot;быстрым&quot; в данном контексте.</p>

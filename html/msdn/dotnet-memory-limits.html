<html><head><title>.NET - Ограничение количества памяти, выделенной процессу</title></head><body>
<p><a href="index.html">Ответы с форумов MSDN</a></p>
<h2>.NET - Ограничение количества памяти, выделенной процессу</h2>
<p>Date: 23.11.2019 10:34:42</p>
<div>
Такой функции нет и не &#1084;ожет быть в ASP.NET, ведь ОЗУ управляет операционная систе&#1084;а, а не фрей&#1084;ворк. Ограничить раз&#1084;ер физической па&#1084;яти процесса в Windows &#1084;ожно, напри&#1084;ер, с по&#1084;ощью функции&nbsp;<a href="https://docs.microsoft.com/ru-ru/windows/win32/api/memoryapi/nf-memoryapi-setprocessworkingsetsizeex?redirectedfrom=MSDN">SetProcessWorkingSetSizeEx</a>.
 Но я ду&#1084;аю, в&#1084;есто того, чтобы ограничивать па&#1084;ять (что довольно бесс&#1084;ысленная затея для веб-приложения), нужно определить реальную пробле&#1084;у и решать ее. С&#1084;. напри&#1084;ер
<a href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/performance">
Garbage Collection and Performance</a>. Просто растущий раз&#1084;ер Working Set - это не пробле&#1084;а, а нор&#1084;альное состояние. Каждый запрос выделяет па&#1084;ять под некоторые объекты, которые сразу не освобождаются, так как сборка &#1084;усора еще
 не запустилась. Эта па&#1084;ять будет освобождена, когда она понадобится други&#1084; приложения&#1084;. Вот если не освобождается, а в&#1084;есто этого падает с OutOfMemoryException, тогда нужно искать утечку или опти&#1084;изировать потребление па&#1084;яти.
</div>
<h2>Message 173</h2>
<p>Date: 23.11.2019 15:00:15</p>
<div>
<p>Существует пара&#1084;етр конфигурации&nbsp;<a href="https://docs.microsoft.com/en-us/dotnet/core/run-time-config/garbage-collector#systemgcheaphardlimitcomplus_gcheaphardlimit">System.GC.HeapHardLimit</a>&nbsp;для ограничения &#1084;акси&#1084;ального раз&#1084;ера
 управляе&#1084;ой кучи, воз&#1084;ожно ва&#1084; это нужно. Или просто периодически вызывать GC.Collect с четверты&#1084; пара&#1084;етро&#1084; true, это вызовет сборку &#1084;усора и сжатие кучи, что должно освободить всю ненужную па&#1084;ять.&nbsp;</p>
<p></p>
<p></p>
<p></p>
</div>
<h2>Message 172</h2>
<p>Date: 24.11.2019 7:40:40</p>
<div>
<p>Опишите подробнее ситуацию:</p>
<p>- Какая ОС</p>
<p>- По какой характеристике оцениваете потребление па&#1084;яти (рабочий набор, виртуальная па&#1084;ять) и через какое ПО ее получаете</p>
<p>- Сколько запросов вы выполняете перед запуско&#1084; сборки &#1084;усора и какое при это&#1084; потребление па&#1084;яти</p>
<p>- До какого значения у&#1084;еньшается потребление па&#1084;яти после сборки &#1084;усора</p>
<p>Да, я и&#1084;ел в виду и&#1084;енно такой вызов GC.Collect. Абсолютно правильно было бы использовать GC.MaxGeneration в&#1084;есто константы 2, но это пока не важно.&nbsp;</p>
<p></p>
</div>
<h2>Message 171</h2>
<p>Date: 24.11.2019 12:59:24</p>
<div>
138 - 130 = 8 MB, это слишко&#1084; &#1084;ало. Когда выделено так &#1084;ало па&#1084;яти, судить о то&#1084;, что та&#1084; освобождается, а что нет, довольно трудно. Воз&#1084;ожно, CLR решает, что при тако&#1084; &#1084;ало&#1084; потреблении нет с&#1084;ысла
 что-то освобождать, так как па&#1084;ять скоро понадобится снова. Кро&#1084;е того, са&#1084; первый вызов GC.Collect &#1084;ожет выделять па&#1084;ять под что-то. Выполните больше запросов, чтобы количество неиспользуе&#1084;ой&nbsp;па&#1084;яти было ощути&#1084;ы&#1084;:
 создайте скрипт, который будет отправлять запросы авто&#1084;атически (с той частотой, которую позволяет хостинг, чтобы сайт не заблокировали) и оставьте его работающи&#1084; на некоторое вре&#1084;я. Зате&#1084; по&#1084;еряйте эффект от GC.Collect при большо&#1084;
 потреблении па&#1084;яти.
</div>
<h2>Message 170</h2>
<p>Date: 24.11.2019 15:18:12</p>
<div>
Пото&#1084;у что GC.CollectionCount возвращает количество прошедших сборок &#1084;усора (авто&#1084;атически или вызово&#1084; GC.Collect) - оно и должно увеличиваться. К потреблению па&#1084;яти оно не и&#1084;еет отношения.
</div>
<h2>Message 169</h2>
<p>Date: 25.11.2019 3:07:25</p>
<div>
Еще раз:&nbsp;<span style="color:#333333; font-family:'Segoe UI','Lucida Grande',Verdana,Arial,Helvetica,sans-serif; font-size:14px"><strong>GC.CollectionCount возвращает количество прошедших сборок &#1084;усора</strong>. Если не было авто&#1084;атических
 сборок, оно равно количеству запусков GC.Collect. Запуск GC.Collect без пара&#1084;етров запускает сборку для всех поколений. Какое другое поведение вы ожидали?</span>
</div>
<h2>Message 168</h2>
<p>Date: 25.11.2019 6:34:23</p>
<div>
<p>Но это не &quot;количество объектов&quot;, это &quot;количество сборок &#1084;усора&quot;. Откуда вы взяли про количество объектов? Даже русская доку&#1084;ентация, хоть и &#1084;ашинный перевод, точно отражает суть: &quot;<span style="color:#171717; font-family:'Segoe UI',SegoeUI,'Segoe WP','Helvetica Neue',Helvetica,Tahoma,Arial,sans-serif; font-size:16px">Возвращает
 количество операций сборки &#1084;усора, выполненных для заданного поколения объектов.</span>&quot;&nbsp;<a href="https://docs.microsoft.com/ru-ru/dotnet/api/system.gc.collectioncount?view=netcore-3.0">https://docs.microsoft.com/ru-ru/dotnet/api/system.gc.collectioncount?view=netcore-3.0</a></p>
<p>Для получения количества объектов в поколении функции нет и никогда не было. Только профилировщики и счетчики производительности &#1084;огут его показывать, и то обычно объе&#1084; па&#1084;яти по поколения&#1084;, а не количество объектов.</p>
</div>

<hr/><p>Автор: <a href="https://smallsoft2.blogspot.com">VadimTagil</a></p>
<p><a href="https://msdn-whiteknight.github.io/answers/html/">Главная страница</a> - <a href="index.html">Список тем</a> - <a href="https://github.com/MSDN-WhiteKnight/answers">Репозиторий на GitHub</a></p>
</body></html>

<html><head><title>Параллельная загрузка файлов</title></head><body>
<p><a href="index.html">Ответы с форумов MSDN</a></p>
<h2>Параллельная загрузка файлов</h2>
<p>Date: 05.09.2017 9:37:33</p>
<div>
<p>Это вполне ожидае&#1084;о. Создание задачи требует определенных ресурсов. На выгоду при распараллеиливании загрузки файлов, зани&#1084;ающей 50 &#1084;с, надеятся не приходится.
</p>
<p>К то&#1084;у же, перед из&#1084;ерение&#1084; производительности, следует убедиться что програ&#1084;&#1084;а корректно работает. Вы используете одну и ту же пере&#1084;енную (n) из нескольких потоков без всякой синхронизации, что не правильно (вы проверяли,
 что програ&#1084;&#1084;а в результате скачивает?)</p>
</div>
<h2>Message 685</h2>
<p>Date: 05.09.2017 17:14:24</p>
<div>
<p>&quot;<em>Даже если сделать 8 отдельных &#1084;етодов без обращения к одной пере&#1084;енной (хотя обращение к пере&#1084;енной только в начале, разве оно влияет на производительность?), производительность падает так, что такое чуство, что операции выполняются
 последовательно.&quot;</em></p>
<p>Речь не о то&#1084;, что это влияет на производительность, а о то&#1084;, что перед из&#1084;ерение&#1084; производительности нужно убедиться в корректности кода (да и решае&#1084;ой задачи). Что вы пытаетесь выяснить? Влияние распараллеливания на скорость
 загрузки файлов? Для этого надо &#1084;ерить су&#1084;&#1084;арное вре&#1084;я, а не вре&#1084;я загрузки одного файла, иначе экспери&#1084;ент не и&#1084;еет с&#1084;ысла.
</p>
<p>Вре&#1084;я загрузки одного файла при параллельной загрузке, определенно, &#1084;ожет быть больше, че&#1084; при последовательной, в определенных ситуациях. Во-первых, параллельность не приходит бесплатно. Если потоков больше, че&#1084; ядер, на переключение
 контекстов потоков расходуется процессорное вре&#1084;я. Во вторых, при параллельной загрузке, во вре&#1084;я скачивания&nbsp;одного файла &#1084;ожет вклиниваться другой поток со свои&#1084; файло&#1084;, и в итоге вре&#1084;я на скачивание одного&nbsp;файла
 становится больше (хотя общее вре&#1084;я на скачивание группы файлов &#1084;ожет быть и &#1084;еньше). При параллельно загрузке как бы теряется понятие &quot;вре&#1084;я на скачивание одного файла&quot;, вре&#1084;я становится &quot;разделяе&#1084;ы&#1084;&quot;.</p>
<p>&quot;<em>И все же вопрос - поче&#1084;у не стоит рассчитывать на выгоду при распараллеливании загрузки зани&#1084;ающей 50 &#1084;с?&quot;</em></p>
<p>Пото&#1084;у что 50 &#1084;с - слишко&#1084; &#1084;алое вре&#1084;я, чтобы за&#1084;етить выигрыш. Тупо погрешность из&#1084;ерения &#1084;ожет перебивать результат.&nbsp;Распаралеливать и&#1084;еет с&#1084;ысл что-то, что длится за&#1084;етное вре&#1084;я,
 нет?</p>
<p>Говоря о выигрыше при &#1084;ногопоточности, следует пони&#1084;ать одну вещь: параллельность полезна, если потоки не конкурируют за общие ресурсы. Бесс&#1084;ысленно гонять 100 потоков на двухъядерно&#1084; процессоре - на переключение контекстов&nbsp;потеряе&#1084;
 больше, че&#1084; на выполнение са&#1084;их задач. Этот же принцип &#1084;ожно распространить и на сеть - если пропускная способность своего канала&nbsp;является ли&#1084;итирующи&#1084; факторо&#1084;, распараллеливание не даст никакого выигрыша; если нет
 - &#1084;ожет и даст. Для исследования &#1084;ожно&nbsp;попробовать вот&nbsp;такую програ&#1084;&#1084;у:</p>
<pre class="prettyprint">	static string[] urls = new string[] {                         
            &quot;http://example.ru/file1.zip&quot;,
            &quot;http://example.ru/file2.zip&quot;,
            &quot;http://example.ru/file3.zip&quot;
        };

        static int n;
        static object sync = new object();
        static System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch();

        static void Main(string[] args)
        {
            WebClient client = new WebClient();
            using (client)
            {
                //предварительно выполни&#1084; длительную операцию,
                //чтобы исключить влияние инициализации CLR на последующие вычисления...
                byte[] data = client.DownloadData(&quot;http://example.com/file.png&quot;);
            }

            n = 0;
            Console.WriteLine(&quot; *** Последовательная загрузка ***&quot;);
            sw.Start();

            //последовательно загрузи&#1084; три файла...
            GetData();
            GetData();
            GetData();

            n = 0;
            Console.WriteLine();
            Console.WriteLine(&quot; *** Параллельная загрузка ***&quot;);
            sw.Reset();
            sw.Start();
            
            //запусти&#1084; три параллельных потока на загрузку тех же файлов...
            for (int i = 0; i &lt; 3; i&#43;&#43;)
            {
                Task t = new Task(GetData);
                t.Start();
            }
            Console.ReadKey();
        }

        static void GetData()
        {
            int count;

            lock (sync)
            {
                count = n;
                n&#43;&#43;;
            }

            WebClient client = new WebClient();

            Console.WriteLine(&quot;Downloading &quot; &#43; count &#43; &quot;, t=&quot; &#43; sw.ElapsedMilliseconds.ToString() &#43; &quot; ms&quot;);
            byte[] data = client.DownloadData(urls[count]);
            Console.WriteLine(&quot;Downloaded &quot; &#43; count &#43; &quot;, t=&quot; &#43; sw.ElapsedMilliseconds.ToString() &#43; &quot; ms&quot;);
            
        }</pre>
<p>Я са&#1084; сейчас не &#1084;огу получить в&#1084;еняе&#1084;ые результаты, так как у WiFi-соединения скорость слишко&#1084; нестабильная. Но предварительно: при загрузке файлов около 20 КБ выигрыша не наблюдается, около &#1084;егабайта - небольшой выигрыш
 есть.</p>
<p></p>
<p></p>
<br/>
</div>

<hr/><p>Автор: <a href="https://smallsoft2.blogspot.com">VadimTagil</a></p>
<p><a href="https://msdn-whiteknight.github.io/answers/html/">Главная страница</a> - <a href="index.html">Список тем</a> - <a href="https://github.com/MSDN-WhiteKnight/answers">Репозиторий на GitHub</a></p>
</body></html>
